# Time-shifted sequences

Not every observable emits items in a timely manner, and even if they do, we might not be able or interested in consuming them. For example, mouse events and UDP packets simply arrive when they arrive. We need tools to decide what to do with the event, not only based on what they are, but also based on when they came.

## Buffer

`buffer` allows you to bulk values together and get them in bulks, rather than one at a time. The are several different ways of buffering values.

### Complete, non-overlapping buffering

First we will examine variant of buffer where every value is buffered exactly once, with no losses and no duplicates.

#### buffer by count

The simplest overload groups a fixed number of values together and emits the group when it's ready.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer3.png)

```java
Observable.range(0, 10)
	.buffer(4)
	.subscribe(System.out::println);
```
Output
```
[0, 1, 2, 3]
[4, 5, 6, 7]
[8, 9]
```

#### buffer by time

The next overload allows to buffer based on time. Time is divided into even pieces. Values are collected for the given timespan and when the time is up, a new collection starts.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.png)

In the next example, we produce values every 100ms and buffer them in windows of 250ms. 

```java
Observable.interval(100, TimeUnit.MILLISECONDS).take(10)
	.buffer(250, TimeUnit.MILLISECONDS)
	.subscribe(System.out::println);
```
Output
```
[0, 1]
[2, 3]
[4, 5, 6]
[7, 8]
[9]
```

The size of a collection here depends on how many values were emitted in that timespan and not on a desired size. The collection can even be empty.

#### buffer by count and time

You can use both a buffer size and a timespan to buffer values. The buffered values are emitted if either the buffer is full or if the time slot ends and a new one starts. Note that, as of the writting of this guide, the [marble diagram for this operator](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.png) is misleading, as it shows that a timespan resets if a buffer is emitted because it is full.

```java
Observable.interval(100, TimeUnit.MILLISECONDS)
	.take(10)
	.buffer(250, TimeUnit.MILLISECONDS, 2)
	.subscribe(System.out::println);
```
Output
```
[0, 1]
[]
[2, 3]
[]
[4, 5]
[6]
[7, 8]
[]
[9]
```

We see a lot of empty lists here. This is because the buffer is emitted when it reaches size 2. As we can see from our previous example, only two values belong in those timeslots, which means that when the slot ends, there are no buffered values.

#### buffer with signal

Instead of fixed points in time, you can also signal to flush a buffer with an observable. Every time your signal emits a value, the values buffered so far will be emitted. Typically, your signal will communicate that the system has just finished processing the previous batch and is ready for the next.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png)

The following example does the same as `.buffer(250, TimeUnit.MILLISECONDS)`

```java
Observable.interval(100, TimeUnit.MILLISECONDS).take(10)
	.buffer(Observable.interval(250, TimeUnit.MILLISECONDS))
	.subscribe(System.out::println);
```

There is a variant for the above way, where you provide the signaling observable through a function: `.buffer(() -> Observable.interval(250, TimeUnit.MILLISECONDS))`. The difference here is that the function that creates the observable is executed when a subscription happens. You can use to start your signal when the subscription starts.

### Overlapping buffers

Every method for buffering that we've seen has an alternative that allows buffers to overloap or to leave out values.

#### buffer by count

When buffering based on the desired buffer size, you can also defined how many elements apart the beginings of the buffers are.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer4.png)

As we can see in the marble diagram, we start a new buffer every 3 values but the buffer is limited to 2 values. Therefore, every third element is left out. You can also start the new buffer before the previous buffer closes. 
* When `count` > `skip`, the buffers overload
* When `count` < `skip`, elements are left out
* The case of `count` = `skip` is equivalent to the case we in the previous subchapter.

Here's an example in code, where the buffers overlap

```java
Observable.range(0,10)
	.buffer(4, 3)
	.subscribe(System.out::println);
```
Output
```
[0, 1, 2, 3]
[3, 4, 5, 6]
[6, 7, 8, 9]
[9]
```

As we can see, a new buffer starts every 3 elements, and that buffer contains the next 4 elements.

#### buffer by time

We can do a very similar thing for the variant that buffers based on a timespan. You decided how frequently to open new buffers and how long they should last.
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.png)
Once again, this allows you either to make your buffers overlap or leave out elements.
* When `timespan` > `timeshift`, the buffers overload
* When `timespan` < `timeshift`, elements are left out
* The case of `timespan` = `timeshift` is equivalent to the case we in the previous subchapter.

In the next example we will create a new buffer every 200ms an have each last 350ms. That means that buffer overlap by 150ms.

```java
Observable.interval(100, TimeUnit.MILLISECONDS).take(10)
	.buffer(350, 200, TimeUnit.MILLISECONDS)
	.subscribe(System.out::println);
```
Output
```
[0, 1, 2]
[2, 3, 4]
[3, 4, 5, 6]
[5, 6, 7, 8]
[7, 8, 9]
[9]
```

#### buffer by signal

The last and most powerful variant or `buffer` allows you to define the start and the end of buffers using signaling observables.
```java
public final <TOpening,TClosing> Observable<java.util.List<T>> buffer(
	Observable<? extends TOpening> bufferOpenings,
	Func1<? super TOpening,? extends Observable<? extends TClosing>> bufferClosingSelector)
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png)

This function takes two arguments. The first argument is an observable. Every time that observable emits a value, a new buffer begins. Along with opening a new buffer, the value that it emitted is passed to the second argument, which is a function. That function uses that value to create a new observable, which will signal the end of the corresponding buffer when it emits its first value.

Let's see this in code:
```java
Observable.interval(100, TimeUnit.MILLISECONDS).take(10)
	.buffer(
		Observable.interval(250, TimeUnit.MILLISECONDS),
		i -> Observable.timer(200, TimeUnit.MILLISECONDS))
	.subscribe(System.out::println);
```
Output
```
[2, 3]
[4, 5]
[7, 8]
[9]
```

We've created an `Observable.interval` that signals the opening of a new buffer every 250ms. Because observables created with `interval` do not immediately emit a value, the first values were lost. For the closing of a buffer, we provided a lambda function that took every value emitted by our buffer-opening observable. The values generated by `interval` are the natural progression 1,2,3... but that doesn't matter, because we discarded that value. Such an example would be too complicated. Instead, we just created an observable that waits 200ms and then emits a single value. That means that each buffer last exactly 200ms, similarily to when buffering by time.

## Delay

#### Continue reading

| Previous | Next |
| --- | --- |
| [Combining sequences](/Part 3 - Taming the sequence/4. Combining sequences.md) | [Hot and cold observables](/Part 3 - Taming the sequence/6. Hot and Cold observables.md) |
