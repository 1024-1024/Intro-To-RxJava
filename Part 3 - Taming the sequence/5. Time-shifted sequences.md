# Time-shifted sequences

Not every observable emits items in a timely manner, and even if they do, we might not be able or interested in consuming them. For example, mouse events and UDP packets simply arrive when they arrive. We need tools to decide what to do with the event, not only based on what they are, but also based on when they came.

## Buffer

`buffer` allows you to bulk values together and get them in bulks, rather than one at a time. The are several different ways of buffering values.

### Complete buffering

First we will examine variant of buffer where every value is buffered exactly once, with no losses and no duplicates.

The simplest overload groups a fixed number of values together and emits the group when it's ready.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer3.png)

```java
Observable.range(0, 10)
	.buffer(4)
	.subscribe(System.out::println);
```
Output
```
[0, 1, 2, 3]
[4, 5, 6, 7]
[8, 9]
```

The next overload allows to buffer based on time. Time is divided into even pieces. Values are collected for the given timespan and when the time is up, a new collection starts.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.png)

In the next example, we produce values every 100ms and buffer them in windows of 250ms. 

```java
Observable.interval(100, TimeUnit.MILLISECONDS).take(10)
	.buffer(250, TimeUnit.MILLISECONDS)
	.subscribe(System.out::println);
```
Output
```
[0, 1]
[2, 3]
[4, 5, 6]
[7, 8]
[9]
```

The size of a collection here depends on how many values were emitted in that timespan and not on a desired size. The collection can even be empty.

You can use both a buffer size and a timespan to buffer values. The buffered values are emitted if either the buffer is full or if the time slot ends and a new one starts. Note that, as of the writting of this guide, the [marble diagram for this operator](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.png) is misleading, as it shows that a timespan resets if a buffer is emitted because it is full.

```java
Observable.interval(100, TimeUnit.MILLISECONDS)
	.take(10)
	.buffer(250, TimeUnit.MILLISECONDS, 2)
	.subscribe(System.out::println);
```
Output
```
[0, 1]
[]
[2, 3]
[]
[4, 5]
[6]
[7, 8]
[]
[9]
```

We see a lot of empty lists here. This is because the buffer is emitted when it reaches size 2. As we can see from our previous example, only two values belong in those timeslots, which means that when the slot ends, there are no buffered values.


Instead of fixed points in time, you can also signal to flush a buffer with an observable. Every time your signal emits a value, the values buffered so far will be emitted. Typically, your signal will communicate that the system has just finished processing the previous batch and is ready for the next.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png)

The following example does the same as `.buffer(250, TimeUnit.MILLISECONDS)`

```java
Observable.interval(100, TimeUnit.MILLISECONDS).take(10)
	.buffer(Observable.interval(250, TimeUnit.MILLISECONDS))
	.subscribe(System.out::println);
```

There is a variant for the above way, where you provide the signaling observable through a function: `.buffer(() -> Observable.interval(250, TimeUnit.MILLISECONDS))`. The difference here is that the function that creates the observable is executed when a subscription happens. You can use to start your signal based in when the subscription started.



#### Continue reading

| Previous | Next |
| --- | --- |
| [Combining sequences](/Part 3 - Taming the sequence/4. Combining sequences.md) | [Hot and cold observables](/Part 3 - Taming the sequence/6. Hot and Cold observables.md) |
