# Combining sequences

So far, we've seen most of the methods that allow us to create a sequence an transform it into what we want. However, most applications have more than one sources of input. We need a way a of combining sequences. We've already seen a few sequences that use more than one observable. In this chapter, we will see some more operators that use multiple sequences to produce one.

## Concatenation

The most straight-forward combination of sequences is to have one run after the other.

### concat

The `concat` operator concatenates sequences one after the other. There are many overliad to `concat` that allow you to provide source observables in different numbers and formats.

```java
public static final <T> Observable<T> concat(
    Observable<? extends Observable<? extends T>> observables)
public static final <T> Observable<T> concat(
    Observable<? extends T> t1,
    Observable<? extends T> t2)
public static final <T> Observable<T> concat(Observable<? extends T> t1,
    Observable<? extends T> t2,
    Observable<? extends T> t3)
public static final <T> Observable<T> concat(Observable<? extends T> t1,
    Observable<? extends T> t2,
    Observable<? extends T> t3,
    Observable<? extends T> t4)
// All the way to 10 observables
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png)

Concatenating two (or more) given observables is very straight forward.

```java
Observable<Integer> seq1 = Observable.range(0, 3);
Observable<Integer> seq2 = Observable.range(10, 3);

Observable.concat(seq1, seq2)
	.subscribe(System.out::println);
```
Output
```
0
1
2
10
11
12
```

If the number of sequences to be combined is dynamic, you can provide an observable that emits the sequences to be concatenated. In this example, we will use our familiar `groupBy` to create a sequence that emits words that start with the same letter together.

```java
Observable<String> words = Observable.just(
	"First",
	"Second",
	"Third",
	"Fourth",
	"Fifth",
	"Sixth"
);

Observable.concat(words.groupBy(v -> v.charAt(0)))
	.subscribe(System.out::println);
```
Output
```
First
Fourth
Fifth
Second
Sixth
Third
```

`concat` seems conceptually similar to the flattening phase of `flatMap`. The key difference is that `flatMap` will interleave the sequences if they are emitting values in parallel, while `concat` will wait for the current sequence to complete before subscribing to the next observable. The example above demonstrates that: the second observable (`Second-Sixth`) begins before first observable (`First-Fourth-Fifth`) is finished, but its values are withheld until the first observable completes.

### repeat

`repeat` allows you to concatenate a sequence after itself, either an infinite or a finite number of times.

```java
public final Observable<T> repeat()
public final Observable<T> repeat(long count)
```

It application is very simple

```java
Observable<Integer> words = Observable.range(0,2);

words.repeat(2)
	.subscribe(System.out::println);
```
Output
```
0
1
0
1
```

`repeat` doesn't cache the values to repeat them. When the time comes, `repeat` will start a new subscription and close the old one. This doesn't always result in the same values being emitted, as we will see in the chapter about hot and cold observables.


### repeatWhen

You can control when the repetition starts with the `repeatWhen` operator. The _when_ is defined by an observable that you provide. When the original sequence completes, it waits for the handling observable to emit something (the value is irrelevant) and only then does it repeat. If the handling observable terminates, that means that the repetitions should stop.

But how would our signaling observable know when a repetition ended and `repeatWhen` is waiting for the signal to start the next? `repeatWhen` provides a special observable that emits `void` when a repetition terminates. You can use that observable to construct your signal.

```java
public final Observable<T> repeatWhen(
    Func1<? super Observable<? extends java.lang.Void>,? extends Observable<?>> notificationHandler)
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.png)

The argument of `repeatWhen` is a function that takes an observable and returns an observable. The types emitted by both objects do not matter. The input is the observable that signals the end of a repetition and the returned observable will be used to signal repetitions.

In the next example, we create our version of `repeat(n)` using `repeatWhen`.

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

values
	.take(2)
	.repeatWhen(ob -> {
		return ob.take(2);
	})
	.subscribe(new PrintSubscriber("repeatWhen"));
```
Output
```
repeatWhen: 0
repeatWhen: 1
repeatWhen: 0
repeatWhen: 1
repeatWhen: Completed
```

Here the repetition happens immediately: `ob` emits when a repetition has started, so the returned observable also emits right after a completed repetition.

In the next example, we create sequence that repeats every two seconds, forever.

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

values
	.take(5)
	.repeatWhen((ob)-> {
		ob.subscribe();
		return Observable.interval(2, TimeUnit.SECONDS);
	})
	.subscribe(new PrintSubscriber("repeatWhen"));
```

Note that the sequence repeats every 2 seconds regardless of when it completed. That's because we created an independent `interval` observable. In the next chapter, [Time-shifted sequences](/Part 3 - Taming the sequence/5. Time-shifted sequences.md), we will see how to deal with sequences in time.

Another thing to note is the `ob.subscribe()` statement, which appears to be useless. That is necessary because it forces `ob` to be created. In the current implementation of `repeatWhen`, if `ob` is not subscribed to, then repetitions never begin.

### startWith

`startWith` takes a sequence and concatenates it before the observable it is applied to.

```java
public final Observable<T> startWith(java.lang.Iterable<T> values)
public final Observable<T> startWith(Observable<T> values)
public final Observable<T> startWith(T t1)
public final Observable<T> startWith(T t1, T t2)
public final Observable<T> startWith(T t1, T t2, T t3)
// up to 10 values
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png)

Here an example

```java
Observable<Integer> values = Observable.range(0, 3);

values.startWith(-1,-2)
	.subscribe(System.out::println);
```
Output
```
-1
-2
0
1
2
```
 
`startWith` is a shorthand for using `concat` with a `just` and our source sequence.

```java
Observable.concat(
	Observable.just(-1,-2,-3),
	values)
// Same as
values.startWith(-1,-2,-3)
```


## Concurrent sequences

Observables aren't always emitting values sequentially. You program may have observables that emit values concurrently.

### amb

`amb`takes a number of observables and returns the one that emit a value first. The rest are discarded.

```java
public static final <T> Observable<T> amb(
	java.lang.Iterable<? extends Observable<? extends T>> sources)
public static final <T> Observable<T> amb(
	Observable<? extends T> o1,
	Observable<? extends T> o2)
public static final <T> Observable<T> amb(
	Observable<? extends T> o1,
	Observable<? extends T> o2,
	Observable<? extends T> o3)
// Up to 10 observables
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png)

In the following example, `amb` will mirror the second observable because it wait less to start.

```java
Observable.amb(
		Observable.timer(100, TimeUnit.MILLISECONDS).map(i -> "First"),
		Observable.timer(50, TimeUnit.MILLISECONDS).map(i -> "Second"))
	.subscribe(System.out::println);
```
Output
```
Second
```

It's usefulness may be not be obvious
> The amb feature can be useful if you have multiple cheap resources that can provide values, but latency is widely variable. For an example, you may have servers replicated around the world. Issuing a query is cheap for both the client to send and for the server to respond, however due to network conditions the latency is not predictable and varies considerably. Using the Amb operator, you can send the same request out to many servers and consume the result of the first that responds.

An alternative style of doing `amb` is the `ambWith` operator.  `ambWith` allows you to combine the observables one by one in a chain. This is more convenient if you are using `amb` in the middle of a chain.

```java
Observable.timer(100, TimeUnit.MILLISECONDS).map(i -> "First")
	.ambWith(Observable.timer(50, TimeUnit.MILLISECONDS).map(i -> "Second"))
	.ambWith(Observable.timer(70, TimeUnit.MILLISECONDS).map(i -> "Third"))
	.subscribe(System.out::println);
```
Output
```
Second
```

### merge

`merge` combines a set of observables into one. The resulting observable emits the values that the source observables emits, as they emit them. That means that values from different sequences are mixed.

```java
public static final <T> Observable<T> merge(
    java.lang.Iterable<? extends Observable<? extends T>> sequences)
public static final <T> Observable<T> merge(java.lang.Iterable<? extends Observable<? extends T>> sequences,
    int maxConcurrent)
public static final <T> Observable<T> merge(
    Observable<? extends Observable<? extends T>> source)
public static final <T> Observable<T> merge(
    Observable<? extends Observable<? extends T>> source,
    int maxConcurrent)
public static final <T> Observable<T> merge(
    Observable<? extends T> t1,
    Observable<? extends T> t2)
public static final <T> Observable<T> merge(
    Observable<? extends T> t1,
    Observable<? extends T> t2,
    Observable<? extends T> t3)
...
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png)

The many overloads are different ways of supplying a set of observables to merge. Here an example of what `merge` does

```java
Observable.merge(
		Observable.interval(250, TimeUnit.MILLISECONDS).map(i -> "First"),
		Observable.interval(150, TimeUnit.MILLISECONDS).map(i -> "Second"))
	.take(10)
	.subscribe(System.out::println);
```
Output
```
Second
First
Second
Second
First
Second
Second
First
Second
First
```

The difference between `concat` and `merge` is that `merge` does not wait for the current observable to terminate before moving to the next. `merge` subscribes to every observable available to it and emits items as they come. It that way, `merge` is similar to the flattening part of `flatMap`.

### switchOnNext

The `switchOnNext` operator takes an observable that emits observables. The returned observable emits items from the most recent observable. As soon as a new observable comes, the old one is discarded and values from the newer one are emitted.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png)

```java
Observable.switchOnNext(
	Observable.interval(100, TimeUnit.MILLISECONDS)
		.map(i -> 
			Observable.interval(30, TimeUnit.MILLISECONDS)
				.map(i2 -> i)
		)
	)
	.take(10)
	.subscribe(System.out::println);
```
Outpu
```
0
0
0
1
1
1
2
2
2
3
```

This example may be a bit confusing. What we've done is create an observable that creates a new observable every 100ms. Every created observable emits it's number in the sequence every 30ms.


## Pairing sequences

### combineLatest

Every time one of the observables provided to `combineLatest` emits an value, that value is is combined with the latest value by the other observable to produce the value that is emitted by `combineLatest`. We define the way they are combined by providing a function

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png)

```java
Observable.combineLatest(
		Observable.interval(100, TimeUnit.MILLISECONDS)
			.doOnNext(i -> System.out.println("Left emits")),
		Observable.interval(150, TimeUnit.MILLISECONDS)
			.doOnNext(i -> System.out.println("Right emits")),
		(i1,i2) -> i1 + " - " + i2
	)
	.take(6)
	.subscribe(System.out::println);
```
Output
```
Left emits
Right emits
0 - 0
Left emits
1 - 0
Left emits
2 - 0
Right emits
2 - 1
Left emits
3 - 1
Right emits
3 - 2
```

As we can see, first it waits for every sequence to have a value. After that, every value emitted by either observable results in a combined value being emitted.

The are overloads for combining more than two sequences. They work with the principle that with described for two sequences.

`combineLatest` is useful when you want a value in the context of another. For example, you may want a scheduled operation to proceed if all the parts are online.

### zip

`zip` is a very basic function out of functional programming. It takes two or more sequences and matches their values one to one by index. Again, a function is require to combine the values.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png)

Let's see our previous example, this time using `zip`

```java
Observable.zip(
	Observable.interval(100, TimeUnit.MILLISECONDS)
		.doOnNext(i -> System.out.println("Left emits " + i)),
	Observable.interval(150, TimeUnit.MILLISECONDS)
		.doOnNext(i -> System.out.println("Right emits " + i)),
	(i1,i2) -> i1 + " - " + i2
	)
	.take(6)
	.subscribe(System.out::println);
```
Output
```
Left emits 0
Right emits 0
0 - 0
Left emits 1
Right emits 1
Left emits 2
1 - 1
Left emits 3
Right emits 2
2 - 2
Left emits 4
Left emits 5
Right emits 3
3 - 3
Left emits 6
Right emits 4
4 - 4
Left emits 7
Right emits 5
Left emits 8
5 - 5
```

As we can see, `zip` matched values based on index.

`zip` has multiple overloads for zipping more than two sequences together.

```java
public static final <R> Observable<R> zip(
    java.lang.Iterable<? extends Observable<?>> ws,
    FuncN<? extends R> zipFunction)
public static final <R> Observable<R> zip(
    Observable<? extends Observable<?>> ws,
    FuncN<? extends R> zipFunction)
public static final <T1,T2,R> Observable<R> zip(
    Observable<? extends T1> o1,
    Observable<? extends T2> o2,
    Func2<? super T1,? super T2,? extends R> zipFunction)
public static final <T1,T2,T3,R> Observable<R> zip(
    Observable<? extends T1> o1,
    Observable<? extends T2> o2,
    Observable<? extends T3> o3,
    Func3<? super T1,? super T2,? super T3,? extends R> zipFunction)
/// etc
```



#### Continue reading

| Previous | Next |
| --- | --- |
| [Advanced error handling](/Part 3 - Taming the sequence/3. Advanced error handling.md) | [Time-shifted sequences](/Part 3 - Taming the sequence/5. Time-shifted sequences.md) |
