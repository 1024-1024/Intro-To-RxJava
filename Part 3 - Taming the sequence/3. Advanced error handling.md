# Advance error handling

We've already seen that we can handle an error in the observer. By that time, we are practically ourside of the monad. There can be many kinds of errors and not every error is worth pushing all the way to the top. In standard Java, you can catch an exception at any level and decide if you want to handle it there or throw it further. Similarily in Rx, you can define behaviour based on errors without killing your observable and forcing the observer to deal with everything.

## Resume

### onErrorReturn

The `onErrorReturn` operator allows you to ignore an error and emit one final value before terminating (successfully this time).

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png)

In the next example, we will convert an error into a normal value to be printed:

```java
Observable<String> values = Observable.create(o -> {
	o.onNext("Rx");
	o.onNext("is");
	o.onError(new Exception("adjective unknown"));
});

values
	.onErrorReturn(e -> "Error: " + e.getMessage())
	.subscribe(v -> System.out.println(v));
```
Output
```
Rx
is
Error: adjective unknown
```

### onErrorResumeNext

The `onErrorResumeNext` allows you to resume a failed sequence with another. The error will not appear in the resulting observable.

```java
public final Observable<T> onErrorResumeNext(
    Observable<? extends T> resumeSequence)
public final Observable<T> onErrorResumeNext(
    Func1<java.lang.Throwable,? extends Observable<? extends T>> resumeFunction)
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png)

The first overload uses the same followup observable in every case. The second overload allows you to decide what the resume sequence should be based on the error that was pushed

```java
Observable<Integer> values = Observable.create(o -> {
	o.onNext(1);
	o.onNext(2);
	o.onError(new Exception("Oops"));
});

values
	.onErrorResumeNext(Observable.just(Integer.MAX_VALUE))
	.subscribe(new PrintSubscriber("with onError: "));
```
Output
```
with onError: 1
with onError: 2
with onError: 2147483647
with onError: Completed
```

There's nothing stopping your resume sequence from failing as well. In fact, if you wanted to change the type of the error, you can return an observable that fails immediatelly. In standard Java, components may decide they can't handle an error and that they should re-throw it. They then may wrap new exceptions around the original error, to provide additional context. You can do the same in Rx:

```java
.onErrorResumeNext(e -> Observable.error(new UnsupportedOperationException(e)))
```

Now the sequence still fails, but you've provided more context. 

### onExceptionResumeNext

`onExceptionResumeNext` only has one difference to `onErrorResumeNext`: it only catches errors that are `Exception`s. 

```java
Observable<String> values = Observable.create(o -> {
	o.onNext("Rx");
	o.onNext("is");
	//o.onError(new Throwable() {}); // this won't be caught
	o.onError(new Exception()); // this will be caught
});

values
	.onExceptionResumeNext(Observable.just("hard"))
	.subscribe(v -> System.out.println(v));
```

## Retry

If the error is not deterministic, we may want to retry. `retry` re-subscribes to the source and starts over.

```java
public final Observable<T> retry()
public final Observable<T> retry(long count)
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png)

If the error doesn't go away, `retry()` will lock us in an infinite loop of retries. The second overload limits the number of retries. If the error persists, `retry(n)` will fail. Lets see this in an example

```java
Random random = new Random();
Observable<Integer> values = Observable.create(o -> {
	o.onNext(random.nextInt() % 20);
	o.onNext(random.nextInt() % 20);
	o.onError(new Exception());
});

values
	.retry(1)
	.subscribe(v -> System.out.println(v));
```
Output
```
0
13
9
15
java.lang.Exception
```

Here. we've specified that we want to retry once. Our observable fails after two values, then tries again, fails again. The second time it fails the exception is allowed through.

In this example, we have done something naughty: we have made our subscription stateful to demonstrate that the observable is restarted from the source. The observable produced different values the second time around. `retry` does not cache any elements like `replay`, nor would it make sense to do so. It will become apparent why this matters once we discuss the differences between hot and cold observables.

## using

The `using` operator is for creating observables from resources that need to managed. It guarantees that your resources will be managed regardless of when and how subscriptions are terminated. If you were to just use `create`, you would have to do the managing in the traditional Java paradigm and inject it into Rx. `using` is a more natural way of managing you resources in Rx.

```java
public static final <T,Resource> Observable<T> using(
    Func0<Resource> resourceFactory,
    Func1<? super Resource,? extends Observable<? extends T>> observableFactory,
    Action1<? super Resource> disposeAction)
```

When a new subscription begins, `resourceFactory` leases the necessary resource. `observableFactory` uses that resource to produce items. When the resource is no longer needed, it is disposed of with the `disposeAction`. The dispose action is executed regardless of the way the subscription terminates (successfully or with a failure).

In the next example, we pretend that a `string` is a resource that needs managing.

```java
Observable<Character> values = Observable.using(
	() -> {
		String resource = "MyResource";
		System.out.println("Leased: " + resource);
		return resource;
	},
	(resource) -> {
		return Observable.create(o -> {
			for (Character c : resource.toCharArray())
				o.onNext(c);
			o.onCompleted();
		});
	},
	(resource) -> System.out.println("Disposed: " + resource));

values
	.subscribe(
		v -> System.out.println(v),
		e -> System.out.println(e));
```
Output
```
Leased: MyResource
M
y
R
e
s
o
u
r
c
e
Disposed: MyResource
```

When we subscribe to `values`, the resource factory function is called which returns the `"MyResource"`. That string is used to produce an observable which emits all of the characters in the string. Once the subscription ends, the string is disposed of.

It is important to note here that we are responsible for terminating the observable. Only then will the resources be released. If we had not called `o.onCompleted()`, the sequence would be assumed to be still active and needing its resources.

A `String` doesn't need any more managing that what the garbage collector will do. `using` should be used for resources that are not released automatically, such as listening on ports, database connections, opening files etc.




#### Continue reading

| Previous | Next |
| --- | --- |
| [Leaving the monad](/Part 3 - Taming the sequence/2. Leaving the monad.md) | [Combining sequences](/Part 3 - Taming the sequence/4. Combining sequences.md) |
