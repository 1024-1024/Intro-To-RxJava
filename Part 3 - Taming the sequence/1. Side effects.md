# PART 3 - Taming the sequence

So far we've learned how to create observables and how to extract relevant data from observables. In this chapter we will go beyond what is necessary for simple examples and discuss more advanced functionality, as well as the practices of using Rx in reality, rather than small examples.

# Side effect

When the operations within a function can affect the outcome of another piece of code, we say that the function has side effect. Functions without side-effects interact with the rest of the program exclusively through their arguments and return values. Common side effects are writes to storage, logging, debugging or prints to an interface.

Side effects can be useful. They also have pitfalls. Any function within an Rx operator can modify a value in a wider score, perform IO operations or update a display. Rx developers are encouraged to try and avoid them, and to have a clear intention when they use side effects.

## Issues with side effects

> Functional programming in general tries to avoid creating any side effects. Functions with side effects, especially which modify state, require the programmer to understand more than just the inputs and outputs of the function. The surface area they are required to understand needs to now extend to the history and context of the state being modified. This can greatly increase the complexity of a function, and thus make it harder to correctly understand and maintain.
> Side effects are not always accidental, nor are they always intentional. An easy way to reduce the accidental side effects is to reduce the surface area for change. The simple actions coders can take are to reduce the visibility or scope of state and to make what you can immutable. You can reduce the visibility of a variable by scoping it to a code block like a method. You can reduce visibility of class members by making them private or protected. By definition immutable data can't be modified so cannot exhibit side effects. These are sensible encapsulation rules that will dramatically improve the maintainability of your Rx code.

We start with an example of an implementation with a side effect. Java doesn't allow references to non-final variables from lambdas (or anonymous implementations in general). However, it won't stop you from modifying the state of object from your lambda. We've created a simple counter as an object:

```java
class Inc {
	private int count = 0;
	public void inc() { 
		count++;
	}
	public int getCount() {
		return count;
	}
}
```

We are going to use this to index the items of an observable

```java
Observable<String> values = Observable.just("No", "side", "effects", "please");
		
Inc index = new Inc();
Observable<String> indexed = 
		values.map(w -> {
			index.inc();
			return w;
		});
indexed.subscribe(w -> System.out.println(index.getCount() + ": " + w));
```
Output
```
1: No
2: side
3: effects
4: please
```

So far it appears ok. Let's see what happens when we try to subscribe to that observable a second time.

```java
Observable<String> values = Observable.just("No", "side", "effects", "please");
		
Inc index = new Inc();
Observable<String> indexed = 
		values.map(w -> {
			index.inc();
			return w;
		});
indexed.subscribe(w -> System.out.println("1st observer: " + index.getCount() + ": " + w));
indexed.subscribe(w -> System.out.println("2nd observer: " + index.getCount() + ": " + w));
```
Output
```
1st observer: 1: No
1st observer: 2: side
1st observer: 3: effects
1st observer: 4: please
2nd observer: 5: No
2nd observer: 6: side
2nd observer: 7: effects
2nd observer: 8: please
```

The second subscriber sees the indexing starting at 5, which is non-sense. While the bug here is straight-forward to discover, side effects can lead to bugs which are a lot more subtle.

## Composing data in a pipeline


#### Continue reading

| Previous | Next |
| --- | --- |
| [Transformation of sequences](/Part 2 - Sequence Basics/5. Transformation of sequences.md) | [Leaving the monad](/Part 3 - Taming the sequence/2. Leaving the monad.md) |
