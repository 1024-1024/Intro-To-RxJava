# Hot and Cold observables

Observable sequences come in two flavours that have important differences. They are called "hot" and "cold". In this chapter, we will explain what each type is and what that means for you as an Rx developer.

## Cold observables

Cold observables are observables that run their sequence when and if they are subscribed to. They present the sequence from its start to each subscriber. An example of a cold observable would be `Observable.interval`. Regardless of when it is created and when it is subscribed to, it will generate the same sequence for every subscriber.

```java
Observable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS);
		
cold.subscribe(i -> System.out.println("First: " + i));
Thread.sleep(500);
cold.subscribe(i -> System.out.println("Second: " + i));
```
Output
```
First: 0
First: 1
First: 2
Second: 0
First: 3
Second: 1
First: 4
Second: 2
...
```

The two subscribers don't receive the same value at the same time, even though they are both subscribed to the same observable. They do see the same sequence, except that each of them sees it as having begun when they subscribed. 

The code samples that we've seen in this guide so far have been cold observables, because cold obserables are easier to reason about. Every observable that is created with the `Observable.create` is a cold observable. That includes all the shorthands that we've seen, such as `just`, `range`, `timer` and `from`. 

Cold observables don't necessarily present the same sequence to each subscriber. If, for example, an observable connects to a database and emits the results of a query, the actual value will depend on the state of the database at the time of subscription. It is the fact that a subscriber will receive the whole query from the start that makes this observable cold.

## Hot observables

Hot observables emit values regardless of subscriptions. They have their own timeline and items are emitted whether someone is listening or not. An example of this is mouse events. A mouse is generating event regardless of whether there is a subscription listening for them. When a subscription is made, the observer receives current events as they happen. You don't receive and you don't want to receive a recap of everything that your mouse has done since you booted your system. When you unsubscribe, it doesn't stop your mouse from generating events either. You're just not receiving them. If you resubscribe, you will again see current events with no recap of what you've missed.

## Publish

There are ways to transform one into the other. You can transform a cold observable into a hot observable by using `publish()`. 

```java
public final ConnectableObservable<T> publish()
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.png)

`publish` returns a `ConnectableObservable<T>`, which is an extension of `Observable<T>` with three additional methods
```java
public final Subscription connect()
public abstract void connect(Action1<? super Subscription> connection)
public Observable<T> refCount()
```

There is a variant that takes a selector that transforms a sequence before publishing it.
```java
public final <R> Observable<R> publish(Func1<? super Observable<T>,? extends Observable<R>> selector)
```
The `selector` can do anything that we've learned to do on observables. This convenience method returns an `Observable<T>` instead of a `ConnectableObservable<T>`, so the connection functionality we are about to discuss does not apply there.

### connect

The `ConnectableObservable` will initially emit nothing. When calling `connect`, it will create a new subscription to its source observable (the one we called `publish` on). It will begin receiving events and pushing them to its subscribers. All of the subscribers will receive the same events at the same time, as they are practically sharing the same subscription: the one that `connect` created.

```java
ConnectableObservable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS).publish();
cold.connect();

cold.subscribe(i -> System.out.println("First: " + i));
Thread.sleep(500);
cold.subscribe(i -> System.out.println("Second: " + i));	
```
Output
```
First: 0
First: 1
First: 2
Second: 2
First: 3
Second: 3
First: 4
Second: 4
First: 5
Second: 5
```

### Disconnecting

As we saw in `connect`'s signature, this method returns a `Subscription`, just like `Observable.subscribe` does. You can use that reference to terminate the `ConnectableObservable`'s subscription. That will stop events from being pushed to observers if `ConnectableObservable` but it will not unsubscribe them. If you call `connect` again, the `ConnectableObservable` will start a new subscription and the old observers will begin receiving values again.

```java
ConnectableObservable<Long> connectable = Observable.interval(200, TimeUnit.MILLISECONDS).publish();
Subscription s = connectable.connect();

connectable.subscribe(i -> System.out.println(i));

Thread.sleep(1000);
System.out.println("Closing connection");
s.unsubscribe();

Thread.sleep(1000);
System.out.println("Reconnecting");
s = connectable.connect();
```
Output
```
0
1
2
3
4
Closing connection
Reconnecting
0
1
2
...
```

When you restart by calling `connect` again, a new subscription will be created. If the source observable is cold, that means that the whole sequence is restarted, even though the resulting observable is hot.

If instead of terminating the connection, you want to unsubscribe from the hot observable, you can use the `Subscription` returned by the `subscribe` method.

```java
ConnectableObservable<Long> connectable = Observable.interval(200, TimeUnit.MILLISECONDS).publish();
Subscription s = connectable.connect();

Subscription s1 = connectable.subscribe(i -> System.out.println("First: " + i));
Thread.sleep(500);
Subscription s2 = connectable.subscribe(i -> System.out.println("Seconds: " + i));

Thread.sleep(500);
System.out.println("Unsubscribing second");
s2.unsubscribe();
```
Output
```
First: 0
First: 1
First: 2
Seconds: 2
First: 3
Seconds: 3
First: 4
Seconds: 4
Unsubscribing second
First: 5
First: 6
```

### refCount

`ConnectableObservable.refCount` returns `Observable<T>` that is connected as long as there are subscribers to it.

```java
Observable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS).publish().refCount();
		
Subscription s1 = cold.subscribe(i -> System.out.println("First: " + i));
Thread.sleep(500);
Subscription s2 = cold.subscribe(i -> System.out.println("Second: " + i));
Thread.sleep(500);
System.out.println("Unsubscribe first");
s2.unsubscribe();
Thread.sleep(500);
System.out.println("Unsubscribe first");
s1.unsubscribe();

System.out.println("First connection again");
Thread.sleep(500);
s1 = cold.subscribe(i -> System.out.println("First: " + i));
```
Output
```
First: 0
First: 1
First: 2
Second: 2
First: 3
Second: 3
Unsubscribe first
First: 4
First: 5
First: 6
Unsubscribe first
First connection again
First: 0
First: 1
First: 2
First: 3
First: 4
```

We see here that the sequence doesn't start until there are subscribers to `refCount`. If they all go away, the connection stops. If more come later, a new connection starts.


## Replay

```java
public final ConnectableObservable<T> replay()
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.png)

`replay` resembles the `ReplaySubject`. Upon connection, it will begin collecting values. Once a new observer subscribes to the observable, it will have all the collected values replayed to it. Once it has caught up, it will receive values in parallel to every other observer.

```java
ConnectableObservable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS).replay();
Subscription s = cold.connect();

System.out.println("Subscribe first");
Subscription s1 = cold.subscribe(i -> System.out.println("First: " + i));
Thread.sleep(700);
System.out.println("Subscribe second");
Subscription s2 = cold.subscribe(i -> System.out.println("Second: " + i));
Thread.sleep(500);
```
Output
```
Subscribe first
First: 0
First: 1
First: 2
Subscribe second
Second: 0
Second: 1
Second: 2
First: 3
Second: 3
```

`replay` returns an `ConnectableObservable` like `publish`, so we can use the same ways to unsubscribe or create a `refCount` observable.

## Multicast

The `share` method is an alias for `Observable.publish().refCount()`. It allows your subscribers to share a subscription. The subscription is kept for as long as there are subscribers.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.png)



#### Continue reading

| Previous | Next |
| --- | --- |
| [Time-shifted sequences](/Part 3 - Taming the sequence/5. Time-shifted sequences.md) | [Custom operators](/Part 3 - Taming the sequence/7. Custom operators.md) |
