# Transformation of sequences

In this chapter we will see ways of changing the format of the data. In the real world, an observable may be of any type. It is very common that the values need to be expanded, trimmed to the relevant parts or simply replaced with something else.

This will complete the three categories of operations. `map` and `flatMap` are the fundamental methods in the "bind" category. In literature, you will often bind them refered to as "bind", for reasons that are beyond the scope of this guide.
* Ana(morphism) `T` --> `IObservable<T>`
* Cata(morphism) `IObservable<T>` --> `T`
* Bind `IObservable<T1>` --> `IObservable<T2>`

In the last chapter we introduced an implementation of `Subscriber` for convenience. We will continue to use it in this example.

```java
class PrintSubscriber extends Subscriber{
	private final String name;
	public PrintSubscriber(String name) {
		this.name = name;
	}
	@Override
	public void onCompleted() {
		System.out.println(name + ": Completed");
	}
	@Override
	public void onError(Throwable e) {
		System.out.println(name + ": Error: " + e);
	}
	@Override
	public void onNext(Object v) {
		System.out.println(name + ": " + v);
	}
}
```

### map

The basic method for transformation is `map` (also known as "select" in SQL-inspired systems like LINQ). It takes a function that takes an item and returns a new item of any type. The returned observable is composed of the values returned by the transformation function.

```java
public final <R> Observable<R> map(Func1<? super T,? extends R> func)
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/map.png)

In the first example, we will take a sequence of integers and increase them by 3

```java
Observable<Integer> values = Observable.range(0,4);
		
values
	.map(i -> i + 3)
	.subscribe(new PrintSubscriber("Map"));
```
Output
```
Map: 3
Map: 4
Map: 5
Map: 6
Map: Completed
```

This was something we could do without `map`. In the following, we will instead emit numbers written as a string and change them into the more processable integer format.

```java
Observable<Integer> values = 
		Observable.just("0", "1", "2", "3")
			.map(s -> Integer.parseInt(s));

values.subscribe(new PrintSubscriber("Map"));
```

Output
```
Map: 0
Map: 1
Map: 2
Map: 3
Map: Completed
```

This transformation is simple enough that we could also do it withing the subscribe method. We changed the style of our examples a little bit to emphasise that mapping a value to another doesn't necessarily enable something otherwise impossible. An observable will often be the API between a component and its users. You could let the user do the parsing, or handle it yourself and present something much neater.

### cast and ofType

`cast` is a shorthand for a transformation that only casts the items to a different type. If you had an `Observable<Object>` that you knew would only only emit values of type `T`, then it is just simpler to `cast` the observable, rather than do the casting in your lambda functions.

```java
Observable<Object> values = Observable.just(0, 1, 2, 3);

values
	.cast(Integer.class)
	.subscribe(new PrintSubscriber("Map"));
```
Output
```
Map: 0
Map: 1
Map: 2
Map: 3
Map: Completed
```

The cast method will fail if not all of the items can be cast to the specified type.

```java
Observable<Object> values = Observable.just(0, 1, 2, "3");

values
	.cast(Integer.class)
	.subscribe(new PrintSubscriber("Map"));
```
Output
```
Map: 0
Map: 1
Map: 2
Map: Error: java.lang.ClassCastException: Cannot cast java.lang.String to java.lang.Integer
```

If you would rather have such cases ignored, you can you the `ofType` method. That works as a filter based on type and a subsequent cast.

```java
Observable<Object> values = Observable.just(0, 1, "2", 3);

values
	.ofType(Integer.class)
	.subscribe(new PrintSubscriber("Map"));
```
Output
```
Map: 0
Map: 1
Map: 3
Map: Completed
```

### timestamp and timeInterval

The `timestamp` and `timeInterval` methods enable us to enrich our values with information with asynchronous nature of Rx. `timestamp` transforms values into the `Timestamped` type, which contains the original value, along with a timestamp for when the event was emitted.

```java
public final Observable<Timestamped<T>> timestamp()
```

Here's an example:

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

values.take(3)
	.timestamp()
	.subscribe(new PrintSubscriber("Timestamp"));
```
Output
```
Timestamp: Timestamped(timestampMillis = 1428611094943, value = 0)
Timestamp: Timestamped(timestampMillis = 1428611095037, value = 1)
Timestamp: Timestamped(timestampMillis = 1428611095136, value = 2)
Timestamp: Completed
```

The timestamp allows us to see that the items were emitted roughly 100ms apart (Java offers few guarantees on that).

If we are more interested in how much time has passed since the last item, rather than the absolute moment in time that the items were emitted, we can use the `timeInterval` method.

```java
public final Observable<TimeInterval<T>> timeInterval()
```

We now use `timeInterval` in the same case as previously

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);
		
values.take(3)
	.timeInterval()
	.subscribe(new PrintSubscriber("TimeInterval"));
```
Output
```
TimeInterval: TimeInterval [intervalInMilliseconds=131, value=0]
TimeInterval: TimeInterval [intervalInMilliseconds=75, value=1]
TimeInterval: TimeInterval [intervalInMilliseconds=100, value=2]
TimeInterval: Completed
```

### materialize and dematerialize

`timestamp` and `timeInterval` are very useful for logging and debugging. Also useful for that purpose is `materialize`. `materialize` transforms a sequence into its metadata representation.

```java
public final Observable<Notification<T>> materialize()
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png)

The notification type can represent any event, not just the emission of values. Notice in the marble diagram that the emission of "onCompleted" did not mean the end of the sequence, as the sequence actually ends afterwards. Here's an example

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);
		
values.take(3)
	.materialize()
	.subscribe(new PrintSubscriber("Materialize"));
```
Output
```
Materialize: [rx.Notification@a4c802e9 OnNext 0]
Materialize: [rx.Notification@a4c802ea OnNext 1]
Materialize: [rx.Notification@a4c802eb OnNext 2]
Materialize: [rx.Notification@18d48ace OnCompleted]
Materialize: Completed
```

The [Notification](http://reactivex.io/RxJava/javadoc/rx/Notification.html) type contains methods for determining the type of the event as well the carried value or `Throwable`, if any.

`dematerialize` will reverse the effects of `materialize`, returning the observable to its normal form.

### flatMap

`map` took one value and returned one other value in its place. `flatMap`'s transformation method produces an `Observable` for every value. 

```java
public final <R> Observable<R> flatMap(Func1<? super T,? extends Observable<? extends R>> func)
```
![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png)

The observable returned by `flatMap` will emit all the values emitted by all the observables produced by the transformation function. Values from the same observable will be in order, but they may be interleaved with values from other observables.

Let's start with a simple example, where `flatMap` is applied on an observable with a single value. `values` will emit a single value, `2`. `flatMap` will turn it into an observable that is the range between `0` and `2`. The values by that observable are emitted in the final observable.

```java
Observable<Integer> values = Observable.just(2);

values
	.flatMap(i -> Observable.range(0,i))
	.subscribe(new PrintSubscriber("flatMap"));
```
Output
```
flatMap: 0
flatMap: 1
flatMap: Completed
```

If `flatMap` is applied on an observable with multiple values, each value will produce a new observable. `values` will emit `1`, `2` and `3`. The resulting observables will respectively be emitting the values `[0]`, `[0,1]` and `[0,1,2]`. The values will be flattened together into one observable: the one that is returned by `flatMap`.

```java
Observable<Integer> values = Observable.range(1,3);

values
	.flatMap(i -> Observable.range(0,i))
	.subscribe(new PrintSubscriber("flatMap"));
```
Output
```
flatMap: 0
flatMap: 0
flatMap: 1
flatMap: 0
flatMap: 1
flatMap: 2
flatMap: Completed
```

Much like `map`, `flatMap`'s input and output type are free to differ. In the next example, we will transform integers into `Character`

```java
Observable<Integer> values = Observable.just(1);
		
values
	.flatMap(i -> 
		Observable.just(
			Character.valueOf((char)(i+64))
	))
	.subscribe(new PrintSubscriber("flatMap"));
```

This hasn't helped us more than the `map` operator. There one key difference that we can exploit to push the example further. While every value must result into an `Observable`, nothing prevents said observable from being empty. We can use that to silenty filter a sequence to what is relevant.

```java
Observable<Integer> values = Observable.range(0,30);
		
values
	.flatMap(i -> {
		if (0 < i && i <= 26)
			return Observable.just(Character.valueOf((char)(i+64)));
		else
			return Observable.empty();
	})
	.subscribe(new PrintSubscriber("flatMap"));
```

This example results in the entire alphabet being printed without errors, even though the initial range exceeds that of the alphabet.

In our examples for `flatMap` so far, the values where in sequence: first all the values from the first observable, then all the values from the second observable. Though this seems intuitive, especially when coming from a synchronous environment, it is important to clarify that this is not the case. The observable returned by `flatMap` emits values as soon as they are available. It just happened that in our examples, all of the observables had all of their values ready immediately. To demonstrate, we construct asynchronous observables using the `interval` method.

```java
Observable.just(100, 150)
	.flatMap(i ->
		Observable.interval(i, TimeUnit.MILLISECONDS)
			.map(v -> i)
	)
	.take(10)
	.subscribe(new PrintSubscriber("flatMap"));
```

We started with the values 100 and 150, which we used as the interval period for the asynchronous observables created in `flatMap`. Since `interval` emits the numbers 1,2,3... in both cases, to better distinguish the two observables, we replaced those values with interval time that each observable operates on.

Output
```
flatMap: 100
flatMap: 150
flatMap: 100
flatMap: 100
flatMap: 150
flatMap: 100
flatMap: 150
flatMap: 100
flatMap: 100
flatMap: 150
flatMap: Completed
```

We can see that the two observables are interleaved into one.




#### Continue reading

| Previous | Next |
| --- | --- |
| [Aggregation](/Part 2 - Sequence Basics/4. Aggregation.md) | [Chapter 3 - Taming the sequence](/Part 3 - Taming the sequence/1. Side effects.md) |
